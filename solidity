// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract EventTicketing is ERC721, Ownable {
    uint256 public nextEventId;
    mapping(uint256 => string) public eventNames;
    mapping(uint256 => uint256) public eventPrices;
    mapping(uint256 => uint256) public eventReputationRequired;
    mapping(uint256 => uint256) public eventTicketSupply;
    mapping(uint256 => uint256) public eventTicketsSold;
    mapping(uint256 => address) public eventOwners;
    mapping(address => mapping(uint256 => bool)) public userEventParticipation;
    mapping(uint256 => uint256) public eventEarnings;
    mapping(uint256 => address) public eventAddresses;
    mapping(address => uint256) public userReputation;

    event EventCreated(uint256 indexed eventId, string name, uint256 price, uint256 reputationRequired, uint256 ticketSupply, address indexed owner, address eventAddress);
    event TicketPurchased(address indexed eventAddress, address indexed buyer, uint256 reputationPoints);
    event Payout(address indexed payee, uint256 amount);
    event ReputationBought(address indexed buyer, uint256 reputationPoints, uint256 cost);

    constructor() ERC721("EventTicket", "ETK") Ownable(msg.sender) {
        nextEventId = 1;
    }

    modifier onlyEventOwner(address eventAddress) {
        uint256 eventId = getEventIdFromAddress(eventAddress);
        require(msg.sender == eventOwners[eventId], "Not the event owner");
        _;
    }

    function getEventIdFromAddress(address eventAddress) public view returns (uint256) {
        for (uint256 i = 1; i < nextEventId; i++) {
            if (eventAddresses[i] == eventAddress) {
                return i;
            }
        }
        revert("Event not found");
    }

    function createEvent(string memory name, uint256 price, uint256 reputationRequired, uint256 ticketSupply) external onlyOwner returns (address) {
        require(ticketSupply > 0, "Ticket supply must be greater than zero");

        eventNames[nextEventId] = name;
        eventPrices[nextEventId] = price;
        eventReputationRequired[nextEventId] = reputationRequired;
        eventTicketSupply[nextEventId] = ticketSupply;
        eventOwners[nextEventId] = msg.sender;

        // Create a unique address for the event
        address eventAddress = address(uint160(uint256(keccak256(abi.encodePacked(address(this), nextEventId)))));

        eventAddresses[nextEventId] = eventAddress;

        emit EventCreated(nextEventId, name, price, reputationRequired, ticketSupply, msg.sender, eventAddress);
        nextEventId++;

        return eventAddress;
    }

    function getAllEvents() external view returns (EventInfo[] memory) {
        EventInfo[] memory events = new EventInfo[](nextEventId - 1);

        for (uint256 i = 1; i < nextEventId; i++) {
            events[i - 1] = EventInfo({
                eventId: i,
                name: eventNames[i],
                price: eventPrices[i],
                reputationRequired: eventReputationRequired[i],
                ticketSupply: eventTicketSupply[i],
                ticketsSold: eventTicketsSold[i],
                owner: eventOwners[i],
                eventAddress: eventAddresses[i]
            });
        }

        return events;
    }

    function getUserParticipation(address user) external view returns (EventParticipation[] memory) {
        uint256 count;
        for (uint256 i = 1; i < nextEventId; i++) {
            if (userEventParticipation[user][i]) {
                count++;
            }
        }

        EventParticipation[] memory result = new EventParticipation[](count);
        count = 0;

        for (uint256 i = 1; i < nextEventId; i++) {
            if (userEventParticipation[user][i]) {
                result[count] = EventParticipation({
                    eventAddress: eventAddresses[i],
                    reputationPoints: eventReputationRequired[i] / 10  // 10% of the reputation required
                });
                count++;
            }
        }

        return result;
    }

    function hasTicket(address user, address eventAddress) external view returns (bool) {
        uint256 eventId = getEventIdFromAddress(eventAddress);
        return userEventParticipation[user][eventId];
    }

    function mintTicket(address eventAddress) external payable {
        uint256 eventId = getEventIdFromAddress(eventAddress);
        require(eventOwners[eventId] != address(0), "Event does not exist");
        require(eventTicketsSold[eventId] < eventTicketSupply[eventId], "No more tickets available");
        require(msg.value == eventPrices[eventId], "Incorrect ticket price");
        require(!userEventParticipation[msg.sender][eventId], "Already participated in this event");
        require(userReputation[msg.sender] >= eventReputationRequired[eventId], "Insufficient reputation");

        uint256 reputationPoints = eventReputationRequired[eventId] / 10;
        userReputation[msg.sender] += reputationPoints;

        _mint(msg.sender, eventId);
        userEventParticipation[msg.sender][eventId] = true;
        eventEarnings[eventId] += msg.value;
        eventTicketsSold[eventId]++;

        emit TicketPurchased(eventAddresses[eventId], msg.sender, reputationPoints);
    }

    function payout(address eventAddress) external onlyEventOwner(eventAddress) {
        uint256 eventId = getEventIdFromAddress(eventAddress);
        require(eventEarnings[eventId] > 0, "No earnings to withdraw");

        uint256 amount = eventEarnings[eventId];
        eventEarnings[eventId] = 0;
        payable(msg.sender).transfer(amount);

        emit Payout(msg.sender, amount);
    }

    function buyReputation() external payable {
        // Define the cost per reputation point (adjust the value as needed)
        uint256 costPerReputation = 1 ether; // 1 ether per reputation point

        // Calculate the number of reputation points based on the amount sent
        uint256 reputationPoints = msg.value / costPerReputation;

        // Ensure the user is buying at least one reputation point
        require(reputationPoints > 0, "Insufficient funds to buy reputation");

        // Update or add to the user's reputation
        userReputation[msg.sender] += reputationPoints;

        emit ReputationBought(msg.sender, reputationPoints, msg.value);
    }

    struct EventInfo {
        uint256 eventId;
        string name;
        uint256 price;
        uint256 reputationRequired;
        uint256 ticketSupply;
        uint256 ticketsSold;
        address owner;
        address eventAddress;
    }

    struct EventParticipation {
        address eventAddress;
        uint256 reputationPoints;
    }
}